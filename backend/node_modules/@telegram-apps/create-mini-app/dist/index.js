#!/usr/bin/env node
import process from "node:process";
import { rm } from "node:fs/promises";
import { resolve } from "node:path";
import chalk from "chalk";
import { program } from "commander";
import { spawn } from "node:child_process";
import ora from "ora";
import { makeTheme, createPrompt, useState, useMemo, useKeypress, isSpaceKey, isEnterKey, isUpKey, isDownKey, Separator, useEffect } from "@inquirer/core";
import figures from "figures";
import ansiEscapes from "ansi-escapes";
import { existsSync } from "node:fs";
import { URL } from "node:url";
const theme = makeTheme({
  style: {
    error(text) {
      return chalk.red(text);
    },
    success(text) {
      return chalk.green(text);
    },
    muted(text) {
      return chalk.dim(text);
    }
  },
  prefixes: {
    pending: chalk.blue("?"),
    info: chalk.blue("i"),
    completed: chalk.green(figures.tick),
    pointer: chalk.green(figures.pointer)
  }
});
function formatError(e) {
  return e instanceof Error ? e.message : typeof e === "string" ? e : JSON.stringify(e);
}
function spawnWithSpinner({
  command,
  title,
  titleFail,
  titleSuccess
}) {
  const { style } = theme;
  const spinner = ora({
    text: style.message(title, "loading"),
    hideCursor: false
  }).start();
  const success = titleSuccess && style.message(titleSuccess, "done");
  if (typeof command === "function") {
    return command().then(() => {
      spinner.succeed(success);
    }).catch((e) => {
      const errString = formatError(e);
      spinner.fail(
        style.error(
          titleFail ? typeof titleFail === "string" ? titleFail : titleFail(errString) : errString
        )
      );
      throw e;
    });
  }
  return new Promise((res, rej) => {
    const proc = spawn(command, { shell: true });
    let errBuf = Buffer.from([]);
    proc.stderr.on("data", (buf) => {
      errBuf = Buffer.concat([errBuf, buf]);
      spinner.suffixText = chalk.bgGray.italic(buf.toString());
    });
    proc.on("exit", (code) => {
      spinner.suffixText = "";
      if (!code) {
        spinner.succeed(success);
        res();
        return;
      }
      const errString = errBuf.length ? errBuf.toString() : `Error code: ${code}`;
      const errorMessage = style.error(
        titleFail ? typeof titleFail === "string" ? titleFail : titleFail(errString) : errString
      );
      spinner.fail(errorMessage);
      rej(new Error(errorMessage));
    });
  });
}
async function cloneTemplate(rootDir, {
  clone: { https, ssh },
  link
}) {
  const titleSuccess = `Cloned template: ${chalk.blue(link)}`;
  try {
    await spawnWithSpinner({
      command: `git clone "${https}" "${rootDir}"`,
      title: `Cloning the template from GitHub (HTTPS): ${chalk.bold.blue(https)}`,
      titleFail: (error) => `Failed to load the template using HTTPS. ${error}`,
      titleSuccess
    });
    return;
  } catch {
  }
  await spawnWithSpinner({
    command: `git clone "${ssh}" "${rootDir}"`,
    title: `Cloning the template from GitHub (SSH): ${chalk.bold.blue(ssh)}`,
    titleFail: (error) => `Failed to load the template using SSH. ${error}`,
    titleSuccess
  });
}
function isGitInstalled() {
  return new Promise((res) => {
    spawn("git --version", { shell: true }).on("exit", (code) => {
      res(!code);
    });
  });
}
function lines(...arr) {
  return arr.flat(1).filter((v) => typeof v === "string").join("\n");
}
function usePromptPrefix(completed) {
  return theme.prefixes[completed ? "completed" : "pending"];
}
function createRepository(name2) {
  return {
    clone: {
      https: `https://github.com/Telegram-Mini-Apps/${name2}.git`,
      ssh: `git@github.com:Telegram-Mini-Apps/${name2}.git`
    },
    link: `github.com/Telegram-Mini-Apps/${name2}`
  };
}
const settings = {
  js: {
    telegramApps: {
      react: "reactjs-js-template",
      solid: "solidjs-js-template",
      next: "nextjs-js-template",
      jquery: "js-template",
      none: "vanillajs-template"
    },
    tsdk: {
      react: "reactjs-js-tsdk-template",
      solid: "solidjs-js-tsdk-template",
      next: "nextjs-js-tsdk-template",
      jquery: "js-tsdk-template",
      none: "vanillajs-tsdk-template"
    }
  },
  ts: {
    telegramApps: {
      react: "reactjs-template",
      solid: "solidjs-template",
      next: "nextjs-template",
      jquery: "typescript-template",
      vue: "vuejs-template"
    },
    tsdk: {
      react: "reactjs-tsdk-template",
      solid: "solidjs-tsdk-template",
      next: "nextjs-tsdk-template",
      jquery: "typescript-tsdk-template"
    }
  }
};
const templates = [];
for (const language in settings) {
  const languageSettings = settings[language];
  for (const sdk in languageSettings) {
    const frameworkSettings = languageSettings[sdk];
    for (const framework in frameworkSettings) {
      templates.push({
        framework,
        sdk,
        language,
        repository: createRepository(frameworkSettings[framework])
      });
    }
  }
}
function findTemplate(language, sdk, framework) {
  return templates.find((t) => t.sdk === sdk && t.language === language && t.framework === framework);
}
function spaces(...arr) {
  return arr.flat(1).filter((v) => typeof v === "string").join(" ");
}
const sections = [
  {
    title: "Language",
    name: "language",
    choices: [
      { title: "TypeScript", value: "ts", defaultChecked: true },
      { title: "JavaScript", value: "js" }
    ]
  },
  {
    title: "SDK",
    name: "sdk",
    choices: [
      { title: "@telegram-apps", value: "telegramApps", defaultChecked: true },
      { title: "Telegram SDK", value: "tsdk" }
    ]
  },
  {
    title: "Framework",
    name: "framework",
    choices: [
      { title: "React.js", value: "react", defaultChecked: true },
      { title: "Solid.js", value: "solid" },
      { title: "Next.js", value: "next" },
      { title: "jQuery", value: "jquery" },
      { title: "Vue.js", value: "vue" },
      { title: "None", value: "none" }
    ]
  }
];
function findTitleByNameAndValue(name2, value) {
  var _a, _b;
  return (_b = (_a = sections.find((s) => s.name === name2)) == null ? void 0 : _a.choices.find((c) => c.value === value)) == null ? void 0 : _b.title;
}
function usePointer() {
  return theme.prefixes.pointer;
}
const CORNER_TOP_LEFT = figures.lineDownBoldRightBold;
const CORNER_TOP_RIGHT = figures.lineDownBoldLeftBold;
const CORNER_BOTTOM_LEFT = figures.lineUpBoldRightBold;
const CORNER_BOTTOM_RIGHT = figures.lineUpBoldLeftBold;
const LINE_HOR_T_DOWN = figures.lineDownBoldLeftBoldRightBold;
const LINE_HOR_T_UP = figures.lineUpBoldLeftBoldRightBold;
const LINE_HOR = figures.lineBold;
const LINE_VER = figures.lineVerticalBold;
const PADDING_HOR_LEFT = 1;
const PADDING_HOR_RIGHT = 3;
const promptTemplate = createPrompt(
  (_, done) => {
    const [x, setX] = useState(0);
    const [y, setY] = useState(0);
    const [selected, setSelected] = useState(
      useMemo(() => {
        return sections.reduce((acc, section) => {
          section.choices.forEach((item) => {
            if (item.defaultChecked) {
              acc[section.name] = item.value;
            }
          });
          return acc;
        }, {
          framework: "react",
          sdk: "telegramApps",
          language: "ts"
        });
      }, [])
    );
    const [completed, setCompleted] = useState(false);
    const template = useMemo(() => {
      return findTemplate(selected.language, selected.sdk, selected.framework);
    }, [selected]);
    const maxY = useMemo(() => sections[x].choices.length - 1, [x]);
    const [lengths, rows] = useMemo(() => {
      const lengths2 = new Array(sections.length).fill(0);
      const rows2 = [[]];
      let maxChoicesCount = 0;
      sections.forEach((section, sIdx) => {
        const sectionTitle = `  ${section.title}`;
        lengths2[sIdx] = Math.max(lengths2[sIdx], sectionTitle.length);
        maxChoicesCount = Math.max(section.choices.length, maxChoicesCount);
        rows2[0].push({
          title: chalk.bold(sectionTitle),
          length: sectionTitle.length
        });
        section.choices.forEach((choice, choiceIdx) => {
          var _a;
          const isActive = sIdx === x && choiceIdx === y;
          const isSelected = selected[section.name] === choice.value;
          const choiceLength = choice.title.length + 4;
          const pointer = isActive ? usePointer() : " ";
          const cursor = isSelected ? template ? chalk.green(figures.radioOn) : chalk.red(figures.radioOn) : theme.style.muted(figures.radioOff);
          lengths2[sIdx] = Math.max(lengths2[sIdx], choiceLength);
          rows2[_a = choiceIdx + 1] || (rows2[_a] = sections.map(() => ({ title: "", length: 0 })));
          rows2[choiceIdx + 1][sIdx] = {
            title: spaces(
              pointer,
              cursor,
              isSelected ? chalk.bold(choice.title) : chalk.dim(choice.title)
            ),
            length: choiceLength
          };
        });
      });
      return [lengths2, rows2];
    }, [x, y, selected]);
    const horizontalColumnLines = lengths.map((l) => {
      return LINE_HOR.repeat(l + PADDING_HOR_LEFT + PADDING_HOR_RIGHT);
    });
    const paddingLeft = " ".repeat(PADDING_HOR_LEFT);
    const paddingRight = " ".repeat(PADDING_HOR_RIGHT);
    const message = spaces(usePromptPrefix(completed), theme.style.message("Preferred technologies:", "idle"));
    if (completed) {
      const lang = findTitleByNameAndValue("language", template.language);
      const framework = findTitleByNameAndValue("framework", template.framework);
      const sdk = findTitleByNameAndValue("sdk", template.sdk);
      return spaces(
        // Message.
        message,
        // Selected technologies.
        `${chalk.bold.blue(framework)}, ${chalk.bold.blue(lang)} and ${chalk.bold.blue(sdk)}`
      );
    }
    useKeypress((key) => {
      if (isSpaceKey(key)) {
        const section = sections[x];
        return setSelected({
          ...selected,
          [section.name]: section.choices[y].value
        });
      }
      if (isEnterKey(key)) {
        if (template) {
          done(template);
          setCompleted(true);
        }
      }
      if (isUpKey(key)) {
        setY(y === 0 ? maxY : y - 1);
        return;
      }
      if (isDownKey(key)) {
        setY(y === maxY ? 0 : y + 1);
        return;
      }
      if (key.name === "right") {
        const nextX = x === sections.length - 1 ? 0 : x + 1;
        const section = sections[nextX];
        if (y >= section.choices.length) {
          setY(section.choices.length - 1);
        }
        return setX(nextX);
      }
      if (key.name === "left") {
        const nextX = x === 0 ? sections.length - 1 : x - 1;
        const section = sections[nextX];
        if (y >= section.choices.length) {
          setY(section.choices.length - 1);
        }
        return setX(nextX);
      }
    });
    return lines(
      // Message.
      message,
      // Upper border.
      [CORNER_TOP_LEFT, horizontalColumnLines.join(LINE_HOR_T_DOWN), CORNER_TOP_RIGHT].join(""),
      // Table body.
      rows.map((row) => [
        // Cell left border.
        LINE_VER,
        paddingLeft,
        row.map((cell, columnIdx) => cell.title + " ".repeat(lengths[columnIdx] - cell.length)).join(`${paddingRight}${LINE_VER}${paddingLeft}`),
        paddingRight,
        // Cell right border.
        LINE_VER
      ].join("")),
      // Lower border.
      [CORNER_BOTTOM_LEFT, horizontalColumnLines.join(LINE_HOR_T_UP), CORNER_BOTTOM_RIGHT].join(""),
      // Help tip.
      // theme.style.help(
      [
        `${theme.style.key("space")} to select`,
        theme.style.key(figures.arrowUp),
        theme.style.key(figures.arrowDown),
        `${theme.style.key(figures.arrowLeft)} and ${theme.style.key(figures.arrowDown)} to change the cursor`
      ].join(", "),
      // ),
      new Separator().separator,
      // Selection status.
      template ? theme.style.success(`A template using these technologies was discovered. Press ${theme.style.key("enter")} to proceed.`) : theme.style.error("Unable to find a template using these technologies"),
      theme.style.help(
        "According to selected technologies, the CLI tool will pick a corresponding template, which will be used as a base for your application."
      ),
      ansiEscapes.cursorHide
    );
  }
);
function useInputPrefix(completed) {
  return theme.style.muted(completed ? figures.ellipsis : figures.pointerSmall);
}
function validate$1(value) {
  if (value.length === 0) {
    return "Directory name should not be empty.";
  }
  if ([".", ".."].includes(value)) {
    return "Value is not valid directory name.";
  }
  if (!value.match(/^[a-zA-Z0-9\-.]+$/)) {
    return "Value contains invalid symbols.";
  }
  if (existsSync(resolve(value))) {
    return `Directory "${value}" already exists`;
  }
}
const promptDirName = createPrompt(
  ({ defaultValue }, done) => {
    const [value, setValue] = useState("");
    const [error, setError] = useState();
    const [completed, setCompleted] = useState(false);
    function confirm(value2) {
      setValue(value2);
      setError(void 0);
      setCompleted(true);
      done(value2);
    }
    useEffect(() => {
      if (completed) {
        done(value);
      }
    }, [completed, done, value]);
    useKeypress((key, rl) => {
      if (completed) {
        return;
      }
      if (isEnterKey(key)) {
        if (!value) {
          const err = defaultValue && validate$1(defaultValue);
          if (err) {
            return setError(err);
          }
          return defaultValue ? confirm(defaultValue) : setError("You have to specify the directory.");
        }
        if (error) {
          rl.clearLine(0);
          rl.clearLine(0);
          rl.write(value);
        }
        return error ? void 0 : confirm(value);
      }
      const input = rl.line;
      setError(input ? validate$1(input) : void 0);
      setValue(input);
    });
    return [
      spaces(
        usePromptPrefix(completed),
        theme.style.message("Directory name:", "idle"),
        useInputPrefix(completed),
        completed ? theme.style.answer(value) : value || (defaultValue ? theme.style.muted(defaultValue) : "")
      ),
      completed ? void 0 : lines(
        theme.style.help("This directory will be used as a root directory for the project. It is allowed to use alphanumeric latin letters, dashes and dots."),
        error ? theme.style.error(error) : void 0
      )
    ];
  }
);
function validate(value) {
  if (value.length === 0) {
    return;
  }
  try {
    new URL(value);
    return "";
  } catch {
  }
  if (value.match(/\w+@[\w\-.]+:[\w-]+\/[\w./]+/)) {
    return;
  }
  return "Value is not considered as URL link or SSH connection string.";
}
const promptGitRepo = createPrompt((_, done) => {
  const [value, setValue] = useState("");
  const [error, setError] = useState();
  const [completed, setCompleted] = useState(false);
  function confirm(value2) {
    setValue(value2);
    setError(void 0);
    setCompleted(true);
    done(value2);
  }
  useEffect(() => {
    if (completed) {
      done(value);
    }
  }, [completed, done, value]);
  useKeypress((key, rl) => {
    if (isEnterKey(key)) {
      if (!value) {
        return confirm("");
      }
      if (error) {
        rl.clearLine(0);
        rl.write(value);
      }
      return error ? void 0 : confirm(value);
    }
    const input = rl.line;
    setError(input ? validate(input) : void 0);
    setValue(input);
  });
  return [
    spaces(
      usePromptPrefix(completed),
      theme.style.message("Git remote repository URL:", "idle"),
      useInputPrefix(completed),
      completed ? theme.style.answer(value ? value : chalk.italic("not specified")) : value
    ),
    lines(
      error ? theme.style.error(error) : void 0,
      !completed && theme.style.help(
        lines(
          "This value will be used to connect created project with your remote Git repository. It should either be an HTTPS link or SSH connection string.",
          `Leave value empty and press ${theme.style.key("enter")} to skip this step.`,
          chalk.bold("Examples"),
          "SSH: git@github.com:user/repo.git",
          "URL: https://github.com/user/repo.git"
        )
      )
    )
  ];
});
const name = "@telegram-apps/create-mini-app";
const version = "1.2.0";
const description = "CLI tool to scaffold your new mini application on the Telegram Mini Apps platform.";
const author = "Vladislav Kibenko <wolfram.deus@gmail.com>";
const homepage = "https://github.com/Telegram-Mini-Apps/telegram-apps#readme";
const repository = {
  type: "git",
  url: "git@github.com:Telegram-Mini-Apps/telegram-apps.git",
  directory: "packages/create-mini-app"
};
const bugs = {
  url: "https://github.com/Telegram-Mini-Apps/telegram-apps/issues"
};
const keywords = [
  "telegram-mini-apps",
  "templates",
  "boilerplates"
];
const license = "MIT";
const type = "module";
const sideEffects = false;
const files = [
  "dist"
];
const bin = "dist/index.js";
const scripts = {
  lint: "cd ../.. && eslint packages/create-mini-app/src --ignore-pattern **/*.test.ts",
  "lint:fix": "pnpm run lint --fix",
  typecheck: "tsc --noEmit",
  build: "vite build",
  watch: "vite build --watch"
};
const devDependencies = {
  "@types/node": "^22.9.0",
  tsconfig: "workspace:*"
};
const publishConfig = {
  access: "public"
};
const dependencies = {
  "@inquirer/core": "^10.1.0",
  "ansi-escapes": "^7.0.0",
  chalk: "^5.3.0",
  commander: "^12.1.0",
  figures: "^6.1.0",
  ora: "^8.1.1"
};
const packageJson = {
  name,
  version,
  description,
  author,
  homepage,
  repository,
  bugs,
  keywords,
  license,
  type,
  sideEffects,
  files,
  bin,
  scripts,
  devDependencies,
  publishConfig,
  dependencies
};
program.name(packageJson.name).description(packageJson.description).version(packageJson.version).action(async () => {
  if (!await isGitInstalled()) {
    console.error("To run this CLI tool, you must have git installed. Installation guide: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git");
    process.exit(1);
  }
  let rootDir = null;
  try {
    rootDir = await promptDirName({ defaultValue: "mini-app" });
  } catch {
    process.exit(0);
  }
  let repository2;
  try {
    const { repository: promptRepo } = await promptTemplate({});
    repository2 = promptRepo;
  } catch {
    process.exit(0);
  }
  let gitRepo;
  try {
    gitRepo = await promptGitRepo({});
  } catch {
    process.exit(0);
  }
  try {
    await cloneTemplate(rootDir, repository2);
  } catch {
    process.exit(1);
  }
  try {
    await spawnWithSpinner({
      title: "Removing the .git directory.",
      command: () => rm(resolve(rootDir, ".git"), { recursive: true }),
      titleFail: (err) => `Failed to remove the .git directory. Error: ${err}`,
      titleSuccess: ".git directory removed."
    });
  } catch {
    process.exit(1);
  }
  if (gitRepo) {
    try {
      await spawnWithSpinner({
        title: `Initializing Git repository: ${gitRepo}`,
        command: [
          `cd "${rootDir}"`,
          "git init",
          "git add -A",
          'git commit -m "first commit"',
          "git branch -M master",
          `git remote add origin "${gitRepo}"`,
          "git push -u origin master"
        ].join(" && "),
        titleFail: (error) => `Failed to initialize Git repository. ${error}`,
        titleSuccess: "Git repository initialized."
      });
    } catch {
    }
  }
  console.log(
    lines(
      chalk.green.bold("Your project has been successfully initialized!"),
      `Now, open the "${chalk.bold(rootDir)}" directory and follow the instructions presented in the ${chalk.bold("README.md")} file. ${chalk.bold("Happy coding! 🚀")}`
    )
  );
});
program.parse();
